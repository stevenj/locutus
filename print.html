<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Locutus Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="dev-guide.html"><strong aria-hidden="true">2.</strong> Development Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="manifest.html"><strong aria-hidden="true">2.1.</strong> Locutus Manifest Format</a></li><li class="chapter-item expanded "><a href="docker.html"><strong aria-hidden="true">2.2.</strong> Building with Docker</a></li></ol></li><li class="chapter-item expanded "><a href="contract-interface.html"><strong aria-hidden="true">3.</strong> Contract Interface</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">4.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Locutus Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><strong>NOTE:</strong> This document is a work in progress. You can <a href="https://github.com/freenet/locutus/issues/new?labels=A-documentation">submit an issue</a> if you find a problem or have a suggestion. The source for this documentation is in our repository at <a href="https://github.com/freenet/locutus/tree/main/docs/src">locutus/docs/src</a>. We welcome pull requests.</p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="what-is-locutus"><a class="header" href="#what-is-locutus">What is Locutus?</a></h2>
<p>Locutus is a global, <a href="https://en.wikipedia.org/wiki/Small-world_network">observable</a>, decentralized key-value store. Values are arbitrary blocks of data, called the contract's &quot;state.&quot; Keys are cryptographic contracts that specify:</p>
<ul>
<li>Whether a given state is permitted under this contract</li>
<li>How the state can be modified over time</li>
<li>How two valid states can be merged</li>
<li>How to efficiently synchronize a contract's state between peers</li>
</ul>
<p>Locutus is a true decentralized peer-to-peer network, and is robust and scalable, through its use of a <a href="https://en.wikipedia.org/wiki/Small-world_network">small-world network</a>.</p>
<p>Applications on Locutus can be built in any language that is supported by web browsers, including JavaScript and WebAssembly. These applications are distributed over Locutus and can create, retrieve, and update contracts through a WebSocket connection to the local Locutus peer.</p>
<h2 id="writing-a-contract"><a class="header" href="#writing-a-contract">Writing a Contract</a></h2>
<p>Locutus contracts can be written in any language that compiles to WebAssembly.
This includes <a href="https://www.rust-lang.org/">Rust</a>, and
<a href="https://www.assemblyscript.org/">AssemblyScript</a>, among many others.</p>
<p>A contract consists of the WebAssembly code itself and its &quot;parameters,&quot; which are additional data like cryptographic keys. This makes it easy to configure contracts without having to recompile them.</p>
<p>A contract can be retrieved using a key, which is a cryptographic hash derived from the contract's WebAssembly code together with its parameters.</p>
<h2 id="small-world-routing"><a class="header" href="#small-world-routing">Small world routing</a></h2>
<p>Locutus peers self-organize into a <a href="https://en.wikipedia.org/wiki/Small-world_routing">small-world network</a> to allow contracts to be found in a fast, scalable, and decentralized way.</p>
<p>Every peer in Locutus is assigned a number between 0 and 1 when it first joins the network, this is the peer's &quot;location&quot;. The small world network topology ensures that peers with similar locations are more likely to be connected.</p>
<p>Contracts also have a location, which is derived from the contract's key. Peers cache contracts close to their locations.</p>
<h2 id="writing-an-application"><a class="header" href="#writing-an-application">Writing an Application</a></h2>
<p>Creating a decentralized application on Locutus is very similar to creating a normal web application. You can use familiar frameworks like React, Bootstrap, Angular, Vue.js, and so on.</p>
<p>The main difference is that instead of connecting to a REST API running on a server, the web application connects to the Locutus peer running on the local computer through a <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a> connection.</p>
<p>Through this the application can:</p>
<ul>
<li>Create new contracts and their associated state</li>
<li>Retrieve contracts and their state</li>
<li>Modify contract state when permitted by the contract</li>
</ul>
<h2 id="how-to-use-contracts"><a class="header" href="#how-to-use-contracts">How to use Contracts</a></h2>
<p>Contracts are extremely flexible. they can be used to create decentralized data structures like hashmaps, inverted indices for keyword search, or efficient buffers for streaming audio and video.</p>
<h2 id="component-ecosystem"><a class="header" href="#component-ecosystem">Component Ecosystem</a></h2>
<p>Applications in Locutus don't need to be built from scratch, they can be built on top of components provided by us or others.</p>
<h3 id="reputation-system"><a class="header" href="#reputation-system">Reputation system</a></h3>
<p>Allows users to build up reputation over time based on feedback from those they interact with. Think of the feedback system in services like Uber, but with Locutus it will be entirely decentralized and cryptographically secure. It can be used for things like spam prevention (with IM and email), or fraud prevention (with an online store).</p>
<p>This is conceptually similar to Freenet's <a href="http://www.draketo.de/english/freenet/friendly-communication-with-anonymity">Web of Trust</a> plugin.</p>
<h3 id="arbiters"><a class="header" href="#arbiters">Arbiters</a></h3>
<p>Arbiters are trusted services that can perform tasks and authenticate the results, such as verifying that a contract had a particular state at a given time, or that external blockchains (Bitcoin, Ethereum, Solana etc) contain specific transactions. Trust is achieved through the reputation system.</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>NOTE:</strong> This document is a work in progress. You can <a href="https://github.com/freenet/locutus/issues/new?labels=A-documentation">submit an issue</a> if you find a problem or have a suggestion. The source for this documentation is in our repository at <a href="https://github.com/freenet/locutus/tree/main/docs/src">locutus/docs/src</a>. We welcome pull requests.</p>
<h1 id="development-guide"><a class="header" href="#development-guide">Development Guide</a></h1>
<p>This guide will walk through how to develop a simple distributed web application using Locutus. To do that, we'll be using Rust for the contracts themselves and Typescript for developing the web application.</p>
<p>At the time of writing (September 2022) the Locutus network is not yet active. We've published this guide so that people can experiment with building and running Locutus applications locally, and provide <a href="https://github.com/freenet/locutus/issues">feedback</a>.</p>
<p>You can see some examples of working applications and contracts in the <code>apps</code> directory of the locutus repository, e.g.:</p>
<ul>
<li><a href="https://github.com/freenet/locutus/tree/main/apps/freenet-microblogging">freenet-microblogging</a> (WIP)</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Development for Locutus requires installing some dependencies:</p>
<h3 id="1-rust--cargo"><a class="header" href="#1-rust--cargo">1. Rust &amp; Cargo</a></h3>
<p>Locutus is developed in <a href="https://www.rust-lang.org/">Rust</a>, on Linux/Mac this will install Rust and its build tool <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html">Cargo</a> which Locutus also requires:</p>
<pre><code class="language-bash">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<h3 id="2-llvm"><a class="header" href="#2-llvm">2. LLVM</a></h3>
<ul>
<li>The <a href="https://llvm.org">LLVM</a> compiler backend core libraries. Usually available at most OS package managers for Linux distributions and Mac OS.</li>
</ul>
<pre><code class="language-bash">$ sudo apt install llvm # For Ubuntu
</code></pre>
<h3 id="3-locutus-dev-tool-ltd"><a class="header" href="#3-locutus-dev-tool-ltd">3. Locutus Dev Tool (LTD)</a></h3>
<p>Once you have a working installation of Cargo you can install the Locutus dev tools:</p>
<pre><code class="language-bash">$ cargo install locutus
</code></pre>
<p>This command will install <code>ldt</code> (Locutus Dev Tool) and a working node that can be used for local development.</p>
<h4 id="31-usage"><a class="header" href="#31-usage">3.1 Usage</a></h4>
<p>You can find more information about the available commands by executing <code>ldt</code> with the <code>--help</code> argument:</p>
<pre><code>$ ldt --help

Locutus Development Tool 0.0.2
The Freenet Project Inc.

USAGE:
    ldt [DATA_DIR] &lt;SUBCOMMAND&gt;

ARGS:
    &lt;DATA_DIR&gt;    Overrides the default data directory where Locutus files are stored

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    build        Builds and packages a contract
    execute      Node CLI
    help         Print this message or the help of the given subcommand(s)
    new          Create a new Locutus contract and/or app
    publish      Publishes a new contract to the network
    run-local    A CLI utility for testing out contracts against a Locutus local node
</code></pre>
<h2 id="creating-a-new-contract"><a class="header" href="#creating-a-new-contract">Creating a new contract</a></h2>
<p>You can create a new <a href="glossary.html#contract">contract</a> skeleton by executing the <code>new</code> command with <code>ldt</code>. Two contract types are supported currently by the tool, regular <a href="glossary.html#contract">contracts</a>, and <a href="glossary.html#web-application">web application</a> <a href="glossary.html#container-contract">container contracts</a>. Currently, the following technological stacks are supported (more to be added in the future):</p>
<ul>
<li>Regular contracts:
<ul>
<li>Rust (<em>default</em>)</li>
</ul>
</li>
<li>Web applications:
<ul>
<li>Container development:
<ul>
<li>Rust (<em>default</em>)</li>
</ul>
</li>
<li>Web/state development:
<ul>
<li>Typescript. (<em>default: using npm and webpack</em>)</li>
<li>JavaScript.</li>
<li>Rust (<strong>WIP</strong>).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We will need to create a directory that will hold our web app and initialize it:</p>
<pre><code class="language-bash">$ mkdir -p my-app/web
$ mkdir -p my-app/backend
$ cd my-app/web
$ ldt new web-app
</code></pre>
<p>will create the skeleton for a web application and its container contract for Locutus ready for development at the <code>my-app/web</code> directory.</p>
<h2 id="making-a-container-contract"><a class="header" href="#making-a-container-contract">Making a container contract</a></h2>
<p>The first thing that we need is to write the code for our container contract. This contract's role is to contain the web application code itself, allowing it to be distributed over Locutus.</p>
<p>The <code>new</code> command has created the source ready to be modified for us, in your favorite editor open the following file:</p>
<pre><code class="language-bash">$ ./container/src/lib.rs
</code></pre>
<p>In this case, and for simplicity's sake, the contract won't be performing any functions, but in a realistic scenario, this contract would include some basic security functionality like verifying that whoever is trying to update the contract has the required credentials.</p>
<p>To make our contract unique so it doesn't collide with an existing contract, we can generate a random signature that will be embedded with the contract.</p>
<!--
What would happen in case of a collision with an existing contract? (That would be if we try to publish a contract that has the same combination of code and parameters.) Then it would fail to publish our contract in the network and would get a rejection because we would be trying to update an existing contract. And we would have to make a slight change in the code/parameters so this collision is avoided. To make this work, there needs to exist a type, which requires (this can be only done once, at the top level of the library crate) implementing the `ContractInterface` trait from `locutus-stdlib`.
-->
<p>For example in the <code>lib.rs</code> file we will write the following:</p>
<pre><code class="language-rust no_run noplayground">use locutus_stdlib::prelude::*;

pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];

struct Contract;

#[contract]
impl ContractInterface for Contract {
    fn validate_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _related: RelatedContracts&lt;'static&gt;,
    ) -&gt; Result&lt;ValidateResult, ContractError&gt; {
        unimplemented!()
    }

    fn validate_delta(
        _parameters: Parameters&lt;'static&gt;,
        _delta: StateDelta&lt;'static&gt;,
    ) -&gt; Result&lt;bool, ContractError&gt; {
        unimplemented!()
    }

    fn update_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _data: Vec&lt;UpdateData&lt;'static&gt;&gt;,
    ) -&gt; Result&lt;UpdateModification&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }

    fn summarize_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
    ) -&gt; Result&lt;StateSummary&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }

    fn get_state_delta(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _summary: StateSummary&lt;'static&gt;,
    ) -&gt; Result&lt;StateDelta&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }
}
</code></pre>
<p>That's a lot of information, let's unpack it:</p>
<pre><code class="language-rust noplayground">use locutus_stdlib::prelude::*;
</code></pre>
<p>Here we are importing the necessary types and traits to write a Locutus contract successfully using Rust.</p>
<pre><code class="language-rust noplayground">pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];
</code></pre>
<p>This will make our contract unique, notice the <code>pub</code> qualifier so the compiler doesn't remove this constant because is unused and is included in the output of the compiler.</p>
<pre><code class="language-rust noplayground">struct Contract;

#[contract]
impl ContractInterface for Contract {
  ...
}
</code></pre>
<!--
TODO: Elsewhere in the documentation, explain the intricate details of how interfacing through WASM works. In theory users could implement their own wrapping code as long as the follow the low level WASM code specification.
-->
<p>Here we create a new type, <code>Contract</code> for which we will be implementing the <code>ContractInterface</code> trait. To know more details about the functionality of a contract, delve into the details of the <a href="contract-interface.html">contract interface</a>.</p>
<p>Notice the <code>#[contract]</code> macro call, this will generate the necessary code for the WASM runtime to interact with your contract ergonomically and safely. Trying to use this macro more than once in the same module will result in a compiler error, and only the code generated at the top-level module will be used by the runtime.</p>
<p>As a rule of thumb, one contract will require implementing the `ContractInterface`` exactly once.</p>
<h3 id="creating-a-web-application"><a class="header" href="#creating-a-web-application">Creating a web application</a></h3>
<p>Now we have a working example of a contract, but our contract is an empty shell, which does not do anything yet. To change this, we will start developing our web application.</p>
<p>To do that, we can go and modify the code of the contract state, which in this case is the web application. Locutus offers a standard library (stdlib) that can be used with Typescript/JavaScript to facilitate the development of web applications and interfacing with your local node, so we will make our <code>package.json</code> contains the dependency:</p>
<pre><code>{
  &quot;dependencies&quot;: {
    &quot;@locutus/locutus-stdlib&quot;: &quot;0.0.2&quot;
  }
}
</code></pre>
<p>Open the file <code>src/index.ts</code> in a code editor and you can start developing the web application.</p>
<p>An important thing to notice is that our application will need to interface with our local node, the entry point for our machine to communicate with other nodes in the network. The stdlib offers a series of facilities in which you will be able to communicate with the network ergonomically.</p>
<p>Here is an example of how you could write your application to interact with the node:</p>
<pre><code class="language-typescript">import { LocutusWsApi } from &quot;@locutus/locutus-stdlib/webSocketInterface&quot;;

const handler = {
  onPut: (_response: PutResponse) =&gt; {},
  onGet: (_response: GetResponse) =&gt; {},
  onUpdate: (_up: UpdateResponse) =&gt; {},
  onUpdateNotification: (_notif: UpdateNotification) =&gt; {},
  onErr: (err: HostError) =&gt; {},
  onOpen: () =&gt; {},
};

const API_URL = new URL(`ws://${location.host}/contract/command/`);
const locutusApi = new LocutusWsApi(API_URL, handler);

const CONTRACT = &quot;DCBi7HNZC3QUZRiZLFZDiEduv5KHgZfgBk8WwTiheGq1&quot;;

async function loadState() {
  let getRequest = {
    key: Key.fromSpec(CONTRACT),
    fetch_contract: false,
  };
  await locutusApi.get(getRequest);
}
</code></pre>
<p>Let's unpack this code:</p>
<pre><code class="language-typescript">const handler = {
  onPut: (_response: PutResponse) =&gt; {},
  onGet: (_response: GetResponse) =&gt; {},
  onUpdate: (_up: UpdateResponse) =&gt; {},
  onUpdateNotification: (_notif: UpdateNotification) =&gt; {},
  onErr: (err: HostError) =&gt; {},
  onOpen: () =&gt; {},
};

const API_URL = new URL(`ws://${location.host}/contract/command/`);
const locutusApi = new LocutusWsApi(API_URL, handler);
</code></pre>
<p>This type provides a convenient interface to the WebSocket API. It receives an object which handles the different responses from the node via callbacks. Here you would be able to interact with DOM objects or other parts of your code.</p>
<pre><code class="language-typescript">const CONTRACT = &quot;DCBi7HNZC3QUZRiZLFZDiEduv5KHgZfgBk8WwTiheGq1&quot;;

async function loadState() {
  let getRequest = {
    key: Key.fromSpec(CONTRACT),
    fetch_contract: false,
  };
  await locutusApi.get(getRequest);
}
</code></pre>
<p>Here we use the API wrapper to make a get request (which requires a key and specifies if we require fetching the contract code or not) to get the state for a contract with the given address. The response from the node will be directed to the <code>onGet</code> callback. You can use any other methods available in the API to interact with the node.</p>
<!--
TODO: Add a link to documentation for the WebSocket API in typescript
-->
<h2 id="writing-the-backend-for-our-web-application"><a class="header" href="#writing-the-backend-for-our-web-application">Writing the backend for our web application</a></h2>
<p>In the <a href="dev-guide.html#creating-a-new-contract">creating a new contract</a> section we described the contract interface, but we were using it to write a simple container contract that won't be doing anything in practice, just carrying around the front end of your application. The core logic of the application, and a back end where we will be storing all the information, requires another contract. So we will create a new contract in a different directory for it:</p>
<pre><code class="language-bash">$ cd ../backend
$ ldt new contract
</code></pre>
<p>This will create a regular contract, and we will need to implement the interface on a type that will handle our contract code. For example:</p>
<pre><code class="language-rust noplayground">use locutus_stdlib::prelude::*;

pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];

struct Contract;

struct Posts(...)

impl Posts {
  fn add_post(&amp;mut self, post: Post) { ... }
}

struct Post(...)

#[contract]
impl ContractInterface for Contract {
    fn update_state(
        _parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        data: Vec&lt;UpdateData&lt;'static&gt;&gt;,
    ) -&gt; Result&lt;UpdateModification&lt;'static&gt;, ContractError&gt; {
        let mut posts: Posts = serde_json::from_slice(&amp;state).map_err(|_| ContractError::InvalidState)?;
        if let Some(UpdateData::Delta(delta)) = data.pop() {
          let new_post: Posts = serde_json::from_slice(&amp;delta).map_err(|_| ContractError::InvalidState);
          posts.add_post(new_post)?;
        } else {
            Err(ContractError::InvalidUpdate)
        }
        Ok(UpdateModification::valid(posts.into()))
    }

    ...
}
</code></pre>
<p>In this simple example, we convert a new incoming delta to a post and the state to a list of posts we maintain, and we append the post to the list of posts. After that, we convert back the posts list to an state and return that.</p>
<p>If we subscribe to the contract changes or our web app, we will receive a notification with the updates after they are successful, and we will be able to render them in our browser. We can do that, for example, using the API:</p>
<pre><code class="language-typescript">function getUpdateNotification(notification: UpdateNotification) {
  let decoder = new TextDecoder(&quot;utf8&quot;);
  let updatesBox = DOCUMENT.getElementById(&quot;updates&quot;) as HTMLPreElement;
  let newUpdate = decoder.decode(Uint8Array.from(notification.update));
  let newUpdateJson = JSON.parse(newUpdate);
  updatesBox.textContent = updatesBox.textContent + newUpdateJson;
}
</code></pre>
<h3 id="building-and-packaging-a-contract"><a class="header" href="#building-and-packaging-a-contract">Building and packaging a contract</a></h3>
<p>Now that we have the front end and the back end of our web app, we can package the contracts and run them in the node to test them out.</p>
<p>In order to do that, we can again use the development tool to help us out with the process. But before doing that, let's take a look at the manifesto format and understand the different parameters that allow us to specify how this contract should be compiled (check the <a href="./manifest.html">manifest</a> details for more information). In the web app directory, we have a <code>locutus.toml</code> file which contains something similar to:</p>
<pre><code class="language-toml">[contract]
type = &quot;webapp&quot;
lang = &quot;rust&quot;

...

[webapp.state-sources]
source_dirs = [&quot;dist&quot;]
</code></pre>
<p>This means that the <code>dist</code> directory will be packaged as the initial state for the webapp (that is the code the browser will be interpreting and in the end, rendering).</p>
<p>If we add the following keys to the manifesto:</p>
<pre><code class="language-toml">[webapp.dependencies]
posts = { path = &quot;../backend&quot; }
</code></pre>
<p>The WASM code from the <code>backend</code> contract will be embedded in our web application state, so it will be accessible as a resource just via the local HTTP gateway access and then we can re-use it for publishing additional contracts.</p>
<!--
TODO: Publishing to the real functioning Locutus network is not yet supported.
-->
<p>Currently, wep applications follow a standarized build procedure in case you use <code>ldt</code> and assumptions about your system. For example, in the case of a <code>type = &quot;webapp&quot;</code> contract, if nothing is specified, it will assume you have <code>npm</code> and the <code>tsc</code> compiler available at the directory level, as well as <code>webpack</code> installed.</p>
<p>This means that you have installed either globally or at the directory level, e.g. globally:</p>
<pre><code>$ npm install -g typescript
$ npm install -g webpack
$ npm install -g webpack-cli
</code></pre>
<p>or locally (make sure your <code>package.json</code> file has the required dependencies):</p>
<pre><code>$ npm install typescript --save-dev
$ npm install webpack --save-dev
$ npm install webpack-cli --save-dev
</code></pre>
<p>If, however, you prefer to follow a different workflow, you can write your own by enabling/disabling certain parameters or using a blank template. For example:</p>
<pre><code>[contract]
lang = &quot;rust&quot;

[state]
files = [&quot;my_packaged_web.tar.xz&quot;]
</code></pre>
<p>Would just delegate the work of building the packaged <code>tar</code> to the developer. Or:</p>
<pre><code>[contract]
type = &quot;webapp&quot;
lang = &quot;rust&quot;

[webapp]
lang = &quot;typescript&quot;

[webapp.typescript]
webpack =  false
</code></pre>
<p>would disable usign <code>webpack</code> at all.</p>
<p>Now that we understand the details, and after making any necessary changes, in each contract directory we run the following commands:</p>
<pre><code class="language-bash">$ ldt build
</code></pre>
<p>This command will read your contract manifest file (<code>locutus.toml</code>) and take care of building the contract and packaging it, ready for the node and the network to consume it.</p>
<!--
TODO: Elsewhere in the documentation, explain the intricate details of building and deploying contracts, in case the use-case doesn't fit with the current tooling, so they know the necessary steeps to interact with the node at a lower level.
-->
<p>Under the <code>./build/locutus</code> directory, you will see both a <code>*.wasm</code> file, which is the contract file, and <code>contract-state</code>, in case it applies, which is the initial state that will be uploaded when initially putting the contract.</p>
<p>Web applications can access the code of backend contracts directly in their applications and put new contracts (that is, assigning a new location for the code, plus any parameters that may be generated dynamically by the web app, and the initial state for that combination of contract code + parameters) dynamically.</p>
<p>Let's take a look at the manifest for our web app container contract:</p>
<h2 id="testing-out-contracts-in-the-local-node"><a class="header" href="#testing-out-contracts-in-the-local-node">Testing out contracts in the local node</a></h2>
<p>Once we have all our contracts sorted and ready for testing, we can do this in local mode in our node. For this the node must be running, we can make sure that is running by running the following command as a background process or in another terminal; since we have installed it:</p>
<pre><code class="language-bash">$ locutus-node
</code></pre>
<p>You should see some logs printed via the stdout of the process indicating that the node HTTP gateway is running.</p>
<p>Once the HTTP gateway is running, we are ready to publish the contracts to our local Locutus node:</p>
<pre><code class="language-bash">$ cd ../backend &amp;&amp; ldt publish --code=&quot;./build/locutus/backend.wasm&quot; --state=&quot;./build/locutus/contract-state&quot;
$ cd ../web &amp;&amp; ldt publish --code=&quot;./build/locutus/web.wasm&quot; --state=&quot;./build/locutus/contract-state&quot;
</code></pre>
<p>In this case, we're not passing any parameters (so our parameters will be an empty byte array), and we are passing an initial state without the current backend contract. In typical use, both the parameters would have meaningful data, and the backend contract may be dynamically generated from the app and published from there.</p>
<p>Once this is done, you can start your app just by pointing to it in the browser: <code>http://127.0.0.1:50509/contract/web/&lt;CONTRACT KEY&gt;</code></p>
<p>For example <code>http://127.0.0.1:50509/contract/web/CYXGxQGSmcd5xHRJNQygPwmUJsWS2njh3pdVjfVz9EV/</code></p>
<p>Iteratively you can repeat this process of modifying, and publishing locally until you are confident with the results and ready to publish your application.</p>
<p>Since the web is part of your state, you are always able to update it, pointing to new contracts, and evolving it over time.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>
<p>Publishing to the Locutus network is not yet supported.</p>
</li>
<li>
<p>Only Rust is currently supported for contract development, but we'll support more languages like <a href="https://www.assemblyscript.org/">AssemblyScript</a> in the future.</p>
</li>
<li>
<p>Binaries for all the required tools are not yet available, they must be compiled from source</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-manifest-format"><a class="header" href="#the-manifest-format">The Manifest Format</a></h1>
<p>The <code>locutus.toml</code> file for each application/contract is called its <em>manifest</em>. It is written in the <a href="https://toml.io/">TOML</a> format. Manifest files consist of the following sections:</p>
<ul>
<li><a href="./manifest.html#the-contract-section">[contract]</a> — Defines a contract.
<ul>
<li><a href="./manifest.html#the-type-field">type</a> — Contract type.</li>
<li><a href="./manifest.html#the-lang-field">lang</a> — Contract source language.</li>
<li><a href="./manifest.html#the-output_dir-field">output_dir</a> — Output path for build artifacts.</li>
</ul>
</li>
<li><a href="./manifest.html#the-contract-section">[webapp]</a> — Configuration for web application containers.</li>
<li><a href="./manifest.html#the-state-section">[state]</a> — Optionally seed a state.</li>
</ul>
<h2 id="the-contract-section"><a class="header" href="#the-contract-section">The <code>[contract]</code> section</a></h2>
<h3 id="the-type-field"><a class="header" href="#the-type-field">The <code>type</code> field</a></h3>
<pre><code class="language-toml">[contract]
...
type = &quot;webapp&quot;
</code></pre>
<p>The type of the contract being packaged. Currently the following types are supported:</p>
<ul>
<li><code>standard</code>, the default type, it can be ellided. This is just a standard <a href="./glossary.html#contract">contract</a>.</li>
<li><code>webapp</code>, a web app <a href="./glossary.html#container-contract">container contract</a>. Additionally to the container contract the web application source will be compiled and packaged as the state of the contract.</li>
</ul>
<h3 id="the-lang-field"><a class="header" href="#the-lang-field">The <code>lang</code> field</a></h3>
<pre><code class="language-toml">[contract]
...
lang = &quot;rust&quot;
</code></pre>
<p>The programming language in which the contract is written. If specified the build tool will compile the contract. Currently only Rust is supported.</p>
<h3 id="the-output_dir-field"><a class="header" href="#the-output_dir-field">The <code>output_dir</code> field</a></h3>
<pre><code class="language-toml">[contract]
...
output_dir = &quot;./other/output/dir/&quot;
</code></pre>
<p>An optional path to the output directory for the build artifacts. If not set the output will be written to the relative directory <code>./build/locutus</code> from the manifest file directory.</p>
<h2 id="the-webapp-section"><a class="header" href="#the-webapp-section">The <code>[webapp]</code> section</a></h2>
<p>An optional section, only specified in case of <code>webapp</code> contracts.</p>
<h3 id="the-lang-field-1"><a class="header" href="#the-lang-field-1">The <code>lang</code> field</a></h3>
<pre><code class="language-toml">[webapp]
...
lang =  &quot;typescript&quot;
</code></pre>
<p>The programming language in which the web application is written. Currently the following languages are supported:</p>
<ul>
<li><code>typescript</code>, requires <a href="https://www.npmjs.com/">npm</a> installed.</li>
<li><code>javascript</code>, requires <a href="https://www.npmjs.com/">npm</a> installed.</li>
</ul>
<h3 id="the-metadata-field"><a class="header" href="#the-metadata-field">The <code>metadata</code> field</a></h3>
<pre><code class="language-toml">[webapp]
...
metadata =  &quot;/path/to/metadata/file&quot;
</code></pre>
<p>An optional path to the metadata for the webapp, if not set the metadata will be empty.</p>
<h3 id="the-webapptypescript-options-section"><a class="header" href="#the-webapptypescript-options-section">The <code>[webapp.typescript]</code> options section</a></h3>
<p>Optional section specified in case of the the <code>typescript</code> lang.</p>
<p>The following fields are supported:</p>
<pre><code class="language-toml">[webapp.typescript]
webpack =  true
</code></pre>
<ul>
<li><code>webpack</code> — if set webpack will be used when packaging the contract state.</li>
</ul>
<h3 id="the-webappjavascript-options-section"><a class="header" href="#the-webappjavascript-options-section">The <code>[webapp.javascript]</code> options section</a></h3>
<p>Optional section specified in case of the the <code>javascript</code> lang.</p>
<p>The following fields are supported:</p>
<pre><code class="language-toml">[webapp.javascript]
webpack =  true
</code></pre>
<ul>
<li><code>webpack</code> — if set webpack will be used when packaging the contract state.</li>
</ul>
<h3 id="the-webappstate-sources-options-section"><a class="header" href="#the-webappstate-sources-options-section">The <code>[webapp.state-sources]</code> options section</a></h3>
<pre><code class="language-toml">[webapp.state-sources]
source_dirs =  [&quot;path/to/sources&quot;]
files = [&quot;*/src/**.js&quot;]
</code></pre>
<p>Specifies the sources for the state of the contract, this will be later on unpacked and accessible at the HTTP gateway from the Locutus node. Includes any web sources (like .html or .js files). The <code>source_dirs</code> field is a comma separated array of directories that should be appended to the root of the state, the <code>files</code> field is a comma separated array of <a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob</a> compatible patterns to files that will be appendeded to the state.</p>
<p>At least one of <code>source_dirs</code>or <code>files</code> fields are required.</p>
<h3 id="the-webappdependencies-section"><a class="header" href="#the-webappdependencies-section">The <code>[webapp.dependencies]</code> section</a></h3>
<pre><code class="language-toml">[webapp.dependencies]
...
posts = { path = &quot;../contracts/posts&quot; }
</code></pre>
<p>An optional list of contract dependencies that will be embedded and available in the state of the contract.
Each entry under this entry represents an alias to the contract code, it must include a <code>path</code> field that specifies the relative location of the dependency from this manifesto directory.</p>
<p>If dependencies are specified they will be compiled and appended to the contract state, under the <code>contracts</code> directory, and as such, become available from the HTTP gateway. A <code>dependencies.json</code> file will be automatically generated and placed under such directory that maps the aliases to the file and hash of the code generated for the dependencies.</p>
<p>In this way the &quot;parent&quot; container contract can use those contracts code to put/update new values through the websocket API in an ergonomic manner.</p>
<h2 id="the-state-section"><a class="header" href="#the-state-section">The <code>[state]</code> section</a></h2>
<pre><code class="language-toml">[state]
files = [&quot;*/src/**.js&quot;]
</code></pre>
<p>An optional section for standard contracts in case they want to seed an state initially, it will take a single file and make it available at the build directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-with-docker-images"><a class="header" href="#building-with-docker-images">Building with Docker Images</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Make sure docker is installed and working, and has the <code>docker compose</code> command.</p>
<h2 id="contract-db-storage"><a class="header" href="#contract-db-storage">Contract DB Storage</a></h2>
<p>The docker image stores its data at <code>/root/.local/share/locutus</code> inside the
container. This is mapped to <code>/tmp/locutus-docker</code> outside the container.</p>
<h2 id="build-the-base-docker-image-of-locutus"><a class="header" href="#build-the-base-docker-image-of-locutus">Build the base docker image of Locutus</a></h2>
<p>All the docker related files are in the <code>docker</code> subdirectory.</p>
<p>Requires that Docker be installed and working.  Then, in the root directory of the repo:</p>
<p>To build the docker locutus container:</p>
<pre><code class="language-sh">cd docker
docker compose build
</code></pre>
<h2 id="running-locutus-node-from-the-docker-image"><a class="header" href="#running-locutus-node-from-the-docker-image">Running Locutus Node from the docker image</a></h2>
<p>Note: Currently the node will not pick up new contracts when they are published.
Make sure the node is stopped and re-started after new contracts are added.</p>
<pre><code class="language-sh">docker compose up
</code></pre>
<h2 id="running-the-ldt-tool-from-the-docker-image"><a class="header" href="#running-the-ldt-tool-from-the-docker-image">Running the <code>ldt</code> tool from the docker image</a></h2>
<p>There is a shell script in the <code>docker</code> sub directory which makes running <code>ldt</code>
from inside the container against source held outside the container easier. It
behaves just like the <code>ldt</code> tool, except as stated below.</p>
<h3 id="getting-help-from-ldt"><a class="header" href="#getting-help-from-ldt">Getting help from <code>ldt</code></a></h3>
<pre><code class="language-sh">/location/of/locutus/docker/ldt.sh --help
</code></pre>
<h3 id="building-contracts"><a class="header" href="#building-contracts">Building Contracts</a></h3>
<p>To BUILD a contract, we need to define 1 or 2 env vars:</p>
<ul>
<li><code>PROJECT_SRC_DIR</code> = Root of the Project being build and defaults to <code>pwd</code> so
if you are in your project root, no need to set it.</li>
<li><code>CONTRACT_SRC_DIR</code> = Relative DIR under PROJECT_SRC_DIR to the Contract to
build. eg, <code>./web</code> would build a contract in the <code>web</code> subdirectory of the
<code>PROJECT_SRC_DIR</code>. Note: This MUST be a subdirectory.</li>
</ul>
<p>eg (in the root of the project):</p>
<pre><code class="language-sh">CONTRACT_SRC_DIR=./web /location/of/locutus/docker/ldt.sh build
</code></pre>
<h3 id="publishing-contracts"><a class="header" href="#publishing-contracts">Publishing Contracts</a></h3>
<p>From the base directory of the contract project.</p>
<pre><code class="language-sh">/location/of/locutus/docker/ldt.sh publish --code target/wasm32-unknown-unknown/release/freenet_microblogging_web.wasm --state web/build/locutus/contract-state
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-interface"><a class="header" href="#contract-interface">Contract Interface</a></h1>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<ul>
<li><a href="glossary#contract-state">Contract State</a> - data associated with a contract that can be retrieved by Applications and Components.</li>
<li><a href="glossary#delta">Delta</a> - Represents a modification to some state - similar to a <a href="https://en.wikipedia.org/wiki/Diff">diff</a> in source code</li>
<li><a href="glossary#parameters">Parameters</a> - Data that forms part of a contract along with the WebAssembly code</li>
<li><a href="glossary#state-summary">State Summary</a> - A compact summary of a contract's state that can be used to create a delta</li>
</ul>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>Locutus contracts must implement the contract interface from <a href="https://github.com/freenet/locutus/blob/main/crates/locutus-stdlib/src/interface.rs">crates/locutus-stdlib/src/interface.rs</a>:</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../crates/locutus-stdlib/src/interface.rs:contractifce}}
</code></pre>
<p><code>Parameters</code>, <code>State</code>, and <code>StateDelta</code> are all wrappers around simple <code>[u8]</code> byte arrays for maximum efficiency and flexibility.</p>
<h2 id="contract-interaction"><a class="header" href="#contract-interaction">Contract Interaction</a></h2>
<p>In the (hopefully) near future we'll be adding the ability for contracts to read each other's state while validating and updating their own, see <a href="https://github.com/freenet/locutus/issues/167">issue #167</a> for the latest on this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="application"><a class="header" href="#application">Application</a></h2>
<p>Software that uses Locutus as a back-end. This includes native software distributed independenly of Locutus but which uses Locutus as a back-end (perhaps bundling Locutus), and <a href="glossary#web-application">web applications</a> that are distributed over Locutus and run in a web browser.</p>
<h2 id="contract"><a class="header" href="#contract">Contract</a></h2>
<p>A contract is WebAssembly code with associated data like the contract state. The role of the contract is to determine:</p>
<ul>
<li>Is the state valid for this contract?</li>
<li>Under what circumstances can the state be modified or updated? (see Delta)</li>
<li>How can two valid states be merged to produce a third valid state?</li>
</ul>
<h2 id="container-contract"><a class="header" href="#container-contract">Container Contract</a></h2>
<p>A contract that contains an application or component as state, accessed through the web proxy.</p>
<p>For example, if the contract id is <code>6C2KyVMtqw8D5wWa8Y7e14VmDNXXXv9CQ3m44PC9YbD2</code> then visiting <code>http://localhost:PORT/contract/web/6C2KyVMtqw8D5wWa8Y7e14VmDNXXXv9CQ3m44PC9YbD2</code> will cause the application/component to be retrieved from Locutus, decompressed, and sent to the browser where it can execute.</p>
<h2 id="contract-state"><a class="header" href="#contract-state">Contract State</a></h2>
<p>Data associated with a contract that can be retrieved by Applications and Components. For efficiency and flexibility, contract state is represented as a simple <code>[u8]</code> byte array.</p>
<h2 id="delta"><a class="header" href="#delta">Delta</a></h2>
<p>Represents a modification to some state - similar to a <a href="https://en.wikipedia.org/wiki/Diff">diff</a> in source code. The exact format of a delta is determined by the contract. A contract will determine whether a delta is valid - perhaps by verifying it is signed by someone authorized to modify the contract state. A delta may be created in response to a <a href="glossary.html#state-summary">State Summary</a> as part of the <a href="glossary.html#state-synchronization">State Synchronization</a> mechanism.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>Data that forms part of a contract along with the WebAssembly code. This is supplied to the contract as a parameter to the contract's functions. Parameters are typically be used to configure a contract, much like the parameters of a constructor function.</p>
<p>For example, the parameters could contain a hash of the state itself. The contract would then use it to verify that the state hashes to that value. This would create a contract that is guaranteed to contain the same state. In the original Freenet, this was known as a <a href="http://justsolve.archiveteam.org/wiki/Content_Hash_Key_(Freenet)">content hash key</a>.</p>
<h2 id="state-summary"><a class="header" href="#state-summary">State Summary</a></h2>
<p>Given a contract state, this is a small piece of data that can be used to determine a <a href="glossary.html#delta">delta</a> between two contracts as part of the <a href="glossary.html#state-synchronization">state synchronization</a> mechanism. The format of a state summary is determined by the state's contract.</p>
<h2 id="state-synchronization"><a class="header" href="#state-synchronization">State Synchronization</a></h2>
<p>Given two valid states for a contract, the state synchronization mechanism allows the states to be efficiently merged over the network to ensure <a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a>.</p>
<h2 id="web-application"><a class="header" href="#web-application">Web Application</a></h2>
<p>Software built on Locutus and distributed through Locutus.</p>
<p>Applications run in the browser and can be built with tools like React, TypeScript, and Vue.js. An application may use multiple components and <a href="glossary.html#contract">contracts</a>.</p>
<p>Applications are compressed and distributed via a <a href="glossary.html#container-contract">container contract</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
